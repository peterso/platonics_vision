#!/usr/bin/env python3
from geometry_msgs.msg import PoseStamped
import rospy
from sensor_msgs.msg import Image
from platonics_vision.localizer_sift import Localizer
from platonics_vision.sift_template import SiftTemplate
from sensor_msgs.msg import CameraInfo
import numpy as np

from platonics_vision.srv import SiftRegistrationLocalizer, SiftRegistrationLocalizerResponse
from platonics_vision.srv import SavingTemplate, SavingTemplateRequest, SavingTemplateResponse
import rospkg
import tf
import yaml

from cv_bridge import CvBridge

class LocalizationService():
    _templates_folder: str

    def __init__(self) -> None:
        rospy.init_node("localization_server")
        self._rate = rospy.Rate(5)

        rospack = rospkg.RosPack()
        self._templates_folder = rospack.get_path("platonics_vision") + "/data/"

        self._localizer = Localizer()
        self.bridge = CvBridge()
        self._publisher_counter = 0
        self._sift_template = SiftTemplate()

        self.establish_ros_connections()

    def handle_save_template_request(self, req: SavingTemplateRequest):
        name_template = self._templates_folder + req.template_name.data
        print("Recording template name: ", name_template)
        self._sift_template.record(img=self._img, depth_img=self._depth_img, name=name_template)
        response = SavingTemplateResponse()
        response.success.data = True
        return response

    def establish_ros_connections(self):
        self.image_publisher = rospy.Publisher("/SIFT_localization", Image, queue_size=10)
        self._service = rospy.Service('sift_localization', SiftRegistrationLocalizer, self.handle_request)
        self._save_template_service = rospy.Service('saving_sift_template', SavingTemplate, self.handle_save_template_request)
        rospy.Subscriber("/camera/color/camera_info", CameraInfo, self.camera_info_callback)
        self.image_sub = rospy.Subscriber('/camera/color/image_raw', Image, self.image_callback)
        self.depth_image_sub = rospy.Subscriber('camera/depth/image_rect_raw', Image, self.depth_image_callback)

    def image_callback(self, img: Image):
        self._img = img

    def depth_image_callback(self, img: Image):
        self._depth_img = img

    def camera_info_callback(self, msg: CameraInfo):
        self.cx_cy_array = np.array([[msg.K[2]], [msg.K[5]]])
        self._fx = msg.K[0]
        self._fy = msg.K[4]
        self._localizer.set_intrinsics(self._fx, self._fy, self.cx_cy_array[0], self.cx_cy_array[1])


    def compute_localization_in_pixels(self, template_folder_name: str):
        cv_image = self.bridge.imgmsg_to_cv2(self._img, "bgr8")
        template_file = self._templates_folder + template_folder_name + "/full_image.png"
        params_file = self._templates_folder + template_folder_name + "/params.yaml"
        params = yaml.load(open(params_file, 'r'), Loader=yaml.FullLoader)
        self._localizer.set_cropping(params['crop'])
        self._localizer.set_box_depth(params['depth'])
        self._localizer.set_template(template_file)
        self._localizer.set_image(cv_image)
        try:
            self._localizer.detect_points()
        except Exception as e:
            print(e)
            print('Returning identity')
            return np.identity(4)
        tf_matrix = self._localizer.compute_full_tf_in_m()
        return tf_matrix
    
    def publish_annoted_image(self):
        ros_image = self.bridge.cv2_to_imgmsg(self._localizer.annoted_image(), "bgr8")
        self.image_publisher.publish(ros_image)


    def handle_request(self, req: SiftRegistrationLocalizer):
        tf_matrix = self.compute_localization_in_pixels(req.template_folder_name.data)
        
        position = tf_matrix[0:3, 3]
        quaternion = tf.transformations.quaternion_from_matrix(tf_matrix[0:4, 0:4])
        quaternion = quaternion/np.linalg.norm(quaternion)
        # Publish pose
        pose = PoseStamped()
        pose.pose.position.x = position[0]
        pose.pose.position.y = position[1]
        pose.pose.position.z = position[2]
        pose.pose.orientation.w = quaternion[3]
        pose.pose.orientation.x = quaternion[0]
        pose.pose.orientation.y = quaternion[1]
        pose.pose.orientation.z = quaternion[2]
        self.publish_annoted_image()
    
        return SiftRegistrationLocalizerResponse(pose)


    def run(self):
        while not rospy.is_shutdown():
            self._rate.sleep()
    
if __name__ == '__main__':
    simple_localizer_node = LocalizationService()
    try:
        simple_localizer_node.run()
    except rospy.ROSInterruptException:
        pass
